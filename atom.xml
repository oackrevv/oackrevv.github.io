<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oackrevv.github.io</id>
    <title>青衫无忧</title>
    <updated>2022-10-28T03:30:46.563Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oackrevv.github.io"/>
    <link rel="self" href="https://oackrevv.github.io/atom.xml"/>
    <subtitle>梦想未完成之前，决不能说放弃！</subtitle>
    <logo>https://oackrevv.github.io/images/avatar.png</logo>
    <icon>https://oackrevv.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 青衫无忧</rights>
    <entry>
        <title type="html"><![CDATA[liunx ubuntu端口]]></title>
        <id>https://oackrevv.github.io/post/pVp3b2Q27/</id>
        <link href="https://oackrevv.github.io/post/pVp3b2Q27/">
        </link>
        <updated>2022-10-28T03:25:45.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>查看防火墙状态，也可以看到开放的端口<code>sudo ufw status</code></li>
<li>关闭防火墙<code>sudo ufw disable</code></li>
<li>开启防火墙<code>sudo ufw enable</code></li>
<li>开放端口<code>sudo ufw allow 端口号</code></li>
<li>关闭端口<code>sudo ufw deny 端口号</code></li>
<li>重启防火墙<code>sudo ufw reload</code></li>
</ol>
<p>端口开启依然无法访问问题排查，查看开启的端口是否有程序监听</p>
<pre><code class="language-php">netstat -ap | grep 端口
</code></pre>
<p>在一台Ubuntu服务器里面配置安装了宝塔，监听的8888端口。本机可以访问，但是局域网就是访问不到。首先怀疑防火墙没有开放8888端口，设置ufw防火墙开放8888端口</p>
<pre><code class="language-php">sudo ufw allow 8888
</code></pre>
<p>然后局域网依然不能访问，接下来应该还要配置一下iptables，开放8080端口</p>
<pre><code class="language-php">sudo iptables -I INPUT -p tcp --dport 8888 -j ACCEPT
</code></pre>
<p>然后局域网就能访问到了。iptables规则设置后是即时生效的,在机器重启后,iptables中的配置信息会被清空，所以需要将配置保存下来。首先将防火墙规则保存到/etc/iptables.up.rules文件中</p>
<pre><code class="language-php">sudo iptables-save &gt; /etc/iptables.up.rules
</code></pre>
<p>然后修改脚本/etc/network/interfaces在网络启动时应用防火墙规则,在末尾添加如下内容</p>
<pre><code class="language-php">pre-up iptables-restore &lt; /etc/iptables.up.rules
</code></pre>
<p>最简单的一个操作：sudo ufw status可检查防火墙的状态，我的返回的是：不活动</p>
<p>sudo ufw version防火墙版本：<br>
ufw 0.29-4ubuntu1<br>
Copyright 2008-2009 Canonical Ltd.</p>
<p>ubuntu 系统默认已安装ufw.</p>
<p>1.安装</p>
<p>sudo apt-get install ufw</p>
<p>2.启用</p>
<p>sudo ufw enable</p>
<p>sudo ufw default deny</p>
<p>运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。</p>
<p>3.开启/禁用</p>
<p>sudo ufw allow|deny [service]</p>
<p>打开或关闭某个端口，例如：</p>
<p>sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口</p>
<p>sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口</p>
<p>sudo ufw allow 53 允许外部访问53端口(tcp/udp)</p>
<p>sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口</p>
<p>sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53</p>
<p>sudo ufw deny smtp 禁止外部访问smtp服务</p>
<p>sudo ufw delete allow smtp 删除上面建立的某条规则</p>
<p>4.查看防火墙状态</p>
<p>sudo ufw status</p>
<p>一般用户，只需如下设置：</p>
<p>sudo apt-get install ufw</p>
<p>sudo ufw enable</p>
<p>sudo ufw default deny</p>
<p>以上三条命令已经足够安全了，如果你需要开放某些服务，再使用sudo ufw allow开启。</p>
<p>开启/关闭防火墙 (默认设置是’disable’)</p>
<p>sudo ufw enable|disable</p>
<p>转换日志状态</p>
<p>sudo ufw logging on|off</p>
<p>设置默认策略 (比如 “mostly open” vs “mostly closed”)</p>
<p>sudo ufw default allow|deny</p>
<p>许 可或者屏蔽端口 (可以在“status” 中查看到服务列表)。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。 ‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’ 则相反。基本语法如下：</p>
<p>sudo ufw allow|deny [service]</p>
<p>显示防火墙和端口的侦听状态，参见 /var/lib/ufw/maps。括号中的数字将不会被显示出来。</p>
<p>sudo ufw status</p>
<p>UFW 使用范例：</p>
<p>允许 53 端口</p>
<p>$ sudo ufw allow 53</p>
<p>禁用 53 端口</p>
<p>$ sudo ufw delete allow 53</p>
<p>允许 80 端口</p>
<p>$ sudo ufw allow 80/tcp</p>
<p>禁用 80 端口</p>
<p>$ sudo ufw delete allow 80/tcp</p>
<p>允许 smtp 端口</p>
<p>$ sudo ufw allow smtp</p>
<p>删除 smtp 端口的许可</p>
<p>$ sudo ufw delete allow smtp</p>
<p>允许某特定 IP</p>
<p>$ sudo ufw allow from 192.168.254.254</p>
<p>删除上面的规则</p>
<p>$ sudo ufw delete allow from 192.168.254.254</p>
<p>linux 2.4内核以后提供了一个非常优秀的防火墙工具：netfilter/iptables,他免费且功能强大，可以对流入、流出的信息进行细化控制，它可以 实现防火墙、NAT（网络地址翻译）和数据包的分割等功能。netfilter工作在内核内部，而iptables则是让用户定义规则集的表结构。</p>
<p>但是iptables的规则稍微有些“复杂”，因此ubuntu提供了ufw这个设定工具，以简化iptables的某些设定，其后台仍然是 iptables。ufw 即uncomplicated firewall的简称，一些复杂的设定还是要去iptables。</p>
<p>ufw相关的文件和文件夹有：</p>
<p>/etc /ufw/：里面是一些ufw的环境设定文件，如 before.rules、after.rules、sysctl.conf、ufw.conf，及 for ip6 的 before6.rule 及 after6.rules。这些文件一般按照默认的设置进行就ok。</p>
<p>若开启ufw之 后，/etc/ufw/sysctl.conf会覆盖默认的/etc/sysctl.conf文件，若你原来的/etc/sysctl.conf做了修 改，启动ufw后，若/etc/ufw/sysctl.conf中有新赋值，则会覆盖/etc/sysctl.conf的，否则还以/etc /sysctl.conf为准。当然你可以通过修改/etc/default/ufw中的“IPT_SYSCTL=”条目来设置使用哪个 sysctrl.conf.</p>
<p>/var/lib/ufw/user.rules 这个文件中是我们设置的一些防火墙规则，打开大概就能看明白，有时我们可以直接修改这个文件，不用使用命令来设定。修改后记得ufw reload重启ufw使得新规则生效。</p>
<p>下面是ufw命令行的一些示例：</p>
<p>ufw enable/disable:打开/关闭ufw</p>
<p>ufw status：查看已经定义的ufw规则</p>
<p>ufw default allow/deny:外来访问默认允许/拒绝</p>
<p>ufw allow/deny 20：允许/拒绝 访问20端口,20后可跟/tcp或/udp，表示tcp或udp封包。</p>
<p>ufw allow/deny servicename:ufw从/etc/services中找到对应service的端口，进行过滤。</p>
<p>ufw allow proto tcp from 10.0.1.0/10 to 本机ip port 25:允许自10.0.1.0/10的tcp封包访问本机的25端口。</p>
<p>ufw delete allow/deny 20:删除以前定义的&quot;允许/拒绝访问20端口&quot;的规则</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DDOS攻击]]></title>
        <id>https://oackrevv.github.io/post/cgHrDnd71/</id>
        <link href="https://oackrevv.github.io/post/cgHrDnd71/">
        </link>
        <updated>2022-10-28T03:25:12.000Z</updated>
        <content type="html"><![CDATA[<p>如何确认是否受到DDOS攻击？<br>
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n<br>
执行后，将会显示服务器上所有的每个IP多少个连接数。如图：<br>
<img src="https://img-blog.csdnimg.cn/5606dc6cf9f144088b483caabc303fd0.png" alt="在这里插入图片描述" loading="lazy"><br>
很明显，前面的数字就是连接数！连接数过大就说明不正常了。</p>
<p>1.服务器内部安装 iftop 流量监控工具</p>
<pre><code class="language-php">yum install iftop -y
</code></pre>
<pre><code> 2.运行下面命令查看流量占用情况
</code></pre>
<pre><code class="language-php">iftop -i eth1 -P
</code></pre>
<p>nginx防止DDOS攻击配置<br>
https://www.nixops.me/articles/nginx-anti-ddos-setting.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://oackrevv.github.io/post/wBSX3vaYO/</id>
        <link href="https://oackrevv.github.io/post/wBSX3vaYO/">
        </link>
        <updated>2022-10-28T03:24:37.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20180629092829788?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" loading="lazy"></figure>
<h2 id="git-全局设置"><strong>Git 全局设置</strong></h2>
<p>git config --global user.name &quot;青衫无忧&quot;<br>
git config --global user.email &quot;905821135@qq.com&quot;</p>
<h2 id="创建git仓库"><strong>创建Git仓库</strong></h2>
<p>mkdir Draw<br>
cd Draw<br>
git init<br>
touch README.md<br>
git add README.md<br>
git commit -m &quot;first commit&quot;<br>
git remote add origin https://gitee.com/Oackrvee/Draw.git<br>
git push -u origin master</p>
<p>已有项目?<br>
cd existing_git_repo<br>
git remote add origin https://gitee.com/Oackrvee/Draw.git<br>
git push -u origin master</p>
<p>提交<br>
git add .<br>
git commit -m &quot;注释内容...&quot;<br>
git push -u origin master</p>
<h2 id="更改远程仓库地址"><strong>更改远程仓库地址</strong></h2>
<p>先删后加<br>
git remote rm origin<br>
git remote add origin [url]</p>
<h2 id="本地项目上传到git"><strong>本地项目上传到git</strong></h2>
<p>http://www.cnblogs.com/eedc/p/6168430.html<br>
1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库<br>
git init</p>
<p>2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件<br>
git add .</p>
<p>3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明<br>
git commit -m 'first commit'</p>
<p>4、关联到远程库<br>
git remote add origin 你的远程库地址<br>
如：<br>
git remote add origin https://github.com/cade8800/ionic-demo.git</p>
<p>5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）<br>
git pull --rebase origin master</p>
<p>6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。<br>
git push -u origin master</p>
<p>*、状态查询命令<br>
git status</p>
<p>备：详细请参考 http://www.cnblogs.com/tugenhua0707/p/4050072.html</p>
<h2 id="git-pull-后恢复本分支原版本"><strong>git pull 后恢复本分支原版本</strong></h2>
<p>问题：git pull 后发现此版本不是想要的版本，但pull后的版本，在我的当前分支版本基础上又迭代了N个版本。</p>
<p>恢复到本分支的原来版本<br>
git reflog master  (查看本地master分支历史变动纪录)<br>
会返回<br>
85bfbdf (master) master@{0}: commit (initial): first commit</p>
<p>然后选择要恢复的版本<br>
$ git reset --hard master@{0}</p>
<h2 id="git配置ssh-key上传本地代码至github"><strong>Git配置SSH Key，上传本地代码至github</strong></h2>
<p>配置全局的name和email</p>
<pre><code>$ git config --global user.name &quot;name&quot;  
$ git config --global user.email &quot;email&quot; 
</code></pre>
<p>1、打开git bash检查是否已经有SSH Key</p>
<pre><code>$ cd ~/.ssh
</code></pre>
<p>2、生成SSH Key</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;
</code></pre>
<p>3、第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件：id_rsa和id_rsa.pub</p>
<p>4、打开<code>C:\Users\Administrator\.ssh</code>下的<code>id_rsa.pub</code>文件，复制该段信息，登录github账户，点击头像进入<code>Settings -&gt; SSH and GPG keys -&gt; New SSH key</code>，将复制的信息粘贴到Key里。</p>
<p>5、测试一下是否成功</p>
<pre><code>$ ssh -T git@github.com
</code></pre>
<p>提示“Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.”说明添加成功。</p>
<h2 id="问题"><strong>问题</strong></h2>
<p>输 入 git add . 后出现</p>
<pre><code>warning: LF will be replaced by CRLF in ......  
The file will have its original line endings in your working directory.  
</code></pre>
<p>解决方法：</p>
<pre><code>git config --global core.autocrlf false
</code></pre>
<p>原因就是：<br>
原因是路径中存在 / 的符号转义问题，false就是不转换符号默认是true，相当于把路径的 / 符号进行转义，这样添加的时候就有问题</p>
<h2 id="常用命令">常用命令</h2>
<p>克隆(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库<br>
提交(commit)：将暂存文件上传到本地仓库（我们在Finder中对本地仓库做修改后一般都得先提交一次，再推送）<br>
检出(checkout)：切换不同分支<br>
添加（add）：添加文件到缓存区<br>
移除（remove）：移除文件至缓存区<br>
暂存(git stash)：保存工作现场<br>
重置(reset)：回到最近添加(add)/提交(commit)状态<br>
合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消<br>
抓取(fetch)：从远程仓库获取信息并同步至本地仓库<br>
拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull=fetch+merge<br>
推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致<br>
分支(branch)：创建/修改/删除分枝<br>
标签(tag):给项目增添标签<br>
工作流(Git Flow):团队工作时，每个人创建属于自己的分枝（branch），确定无误后提交到master分枝<br>
终端(terminal):可以输入git命令行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[liunx下使用SRS搭建直播流媒体服务器]]></title>
        <id>https://oackrevv.github.io/post/oI4kBlnM5/</id>
        <link href="https://oackrevv.github.io/post/oI4kBlnM5/">
        </link>
        <updated>2022-10-28T03:21:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开始编译安装">开始编译安装</h2>
<pre><code class="language-php">git clone -b 4.0release https://gitee.com/ossrs/srs.git
cd srs/trunk
./configure &amp;&amp; make 
vi ./conf/srs.conf #修改配置，如下
</code></pre>
<h2 id="srsconf-配置">srs.conf 配置</h2>
<pre><code class="language-php"># main config for srs.
# @see full.conf for detail config.

listen              1935;
max_connections     1000;
srs_log_tank        file;
srs_log_file        ./objs/srs.log;
daemon              on;
http_api {
    enabled         on;
    listen          1985;
}
http_server {
    enabled         on;
    listen          8080;
    dir             ./objs/nginx/html;
}
stats {
    network         0;
}
rtc_server {
    enabled on;
    # Listen at udp://8000
    listen 8000;
    #
    # The $CANDIDATE means fetch from env, if not configed, use * as default.
    #
    # The * means retrieving server IP automatically, from all network interfaces,
    # @see https://github.com/ossrs/srs/wiki/v4_CN_RTCWiki#config-candidate
    candidate $CANDIDATE;
}

vhost __defaultVhost__ {
    rtc {
        enabled     on;
        rtc_to_rtmp on;
        bframe      discard;
        stun_timeout    30;
        stun_strict_check on;
        dtls_role  passive;
        dtls_version auto;
        drop_for_pt 0;
    }
    
    hls {
        enabled         on;
    }
    http_remux {
        enabled     on;
        mount       [vhost]/[app]/[stream].flv;
        hstrs       on;
    }
    
    tcp_nodelay     on
    min_latency     on;
    
    play {
        gop_cache       off;
        queue_length    10;
        mw_latency      0;
        mw_msgs         1;
    }
    
    publish {
        mr off;
    }
    
    http_hooks {
        enabled         on;
        on_connect      http://127.0.0.1:8085/callback/srsCallback/onConnect;
        on_close        http://127.0.0.1:8085/callback/srsCallback/onClose;
        on_publish      http://127.0.0.1:8085/callback/srsCallback/onPublish;
        on_unpublish    http://127.0.0.1:8085/callback/srsCallback/onUnpublish;
        on_play         http://127.0.0.1:8085/callback/srsCallback/onPlay;
        on_stop         http://127.0.0.1:8085/callback/srsCallback/onStop;
        on_dvr          http://127.0.0.1:8085/callback/srsCallback/onDvr;
    }
    dvr {
         enabled         on;
         dvr_apply       all;
         dvr_path        ./objs/nginx/html/[app]/[2006]/[01]/[02]/[stream].[15][04][05].[999].flv;
         dvr_duration    30;
         dvr_wait_keyframe on;
         time_jitter      full;
    }
}


</code></pre>
<p>保存退出，之后启动srs，<strong>要记得放行对应的端口 ,可看<a href="https://www.cnblogs.com/ubiquitousShare/p/13135747.html">https://www.cnblogs.com/ubiquitousShare/p/13135747.html</a></strong></p>
<pre><code class="language-php">./objs/srs -c conf/srs.conf
</code></pre>
<h2 id="srs常用命令">srs常用命令</h2>
<blockquote>
<p>在/srs/trunk下执行<br>
.<code>/etc/init.d/srs start</code> #启动srs<br>
<code>./etc/init.d/srs restart</code> #重启srs<br>
<code>./etc/init.d/srs stop</code> #关闭srs<br>
<code>./etc/init.d/srs status</code> #查看srs状态<br>
<code>tail -f ./objs/srs.log</code> #查看srs日志</p>
</blockquote>
<h2 id="推流地址">推流地址</h2>
<blockquote>
<p>WebRTC推流：<code>webrtc://192.168.88.115/live/livestream</code><br>
或<br>
rtmp推流：<code>rtmp://192.168.88.115/live/livestream</code></p>
</blockquote>
<h2 id="拉流对应地址">拉流对应地址</h2>
<blockquote>
<p>VLC(RTMP)：<code>rtmp://192.168.88.115/live/livestream</code><br>
H5(HTTP-FLV)： <code>http://192.168.88.115:8080/live/livestream.flv</code><br>
H5(HLS)：<code>http://192.168.88.115:8080/live/livestream.m3u8</code><br>
H5(WebRTC)： <code>webrtc://192.168.88.115/live/livestream</code></p>
</blockquote>
<blockquote>
<p>也可以使用SRS进行推流拉流，浏览器访问<code>http://192.168.88.115:8080/</code></p>
</blockquote>
<h2 id="源码地址">源码地址</h2>
<blockquote>
<p>Github：<a href="https://github.com/ossrs/srs">https://github.com/ossrs/srs</a><br>
Gitee：<a href="https://gitee.com/ossrs/srs">https://gitee.com/ossrs/srs</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[php+nginx+swoole+redis+mysql搭建]]></title>
        <id>https://oackrevv.github.io/post/0SnPcEiFK/</id>
        <link href="https://oackrevv.github.io/post/0SnPcEiFK/">
        </link>
        <updated>2022-10-28T03:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-安装php">一、安装php</h2>
<p>1、下载php</p>
<pre><code class="language-php">wget https://www.php.net/distributions/php-7.4.30.tar.gz
</code></pre>
<p>2、解压</p>
<pre><code class="language-php">tar –xf php-7.4.30.tar.gz
</code></pre>
<p>3、进入目录</p>
<pre><code class="language-php">cd php-7.4.30
</code></pre>
<p>4、编译安装</p>
<pre><code class="language-php">./configure --prefix=/usr/local/php  --with-zlib --enable-zip --with-openssl --enable-fpm --enable-mbstring --with-libdir=lib64 --without-pear  --disable-phar
</code></pre>
<p>注：<br>
如果要连接mysql，需要加上 --with-mysql=/usr/local/mysql<br>
如果想后装mysql，需要加上 --with-mysql=mysqlnd<br>
如果连接nginx，最好加上 --with-fpm-user=www  --with-fpm-group=www</p>
<p>全部如下</p>
<pre><code>./configure --prefix=/usr/local/php --with-mysql=/usr/local/mysql --with-curl --with-freetype-dir --with-gd --with-gettext--with-iconv-dir --with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pdo-sqlite --with-pear --with-png-dir --with-jpeg-dir --with-xmlrpc --with-xsl --with-zlib --with-bz2 --with-mhash --enable-fpm --enable-bcmath --enable-libxml --enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-sysvshm --enable-xml --enable-zip
</code></pre>
<p>注：32位系统要去掉--with-libdir=lib64</p>
<p>5、配置完成之后，执行以下命令</p>
<pre><code class="language-php">make &amp;&amp; make install
</code></pre>
<p>6、配置php，这是php的配置文件</p>
<pre><code class="language-php">cp /home/php-7.2.34/php.ini-development /usr/local/php/lib/php.ini
</code></pre>
<p>7、配置php-fpm.conf，这是php-fpm配置文件</p>
<pre><code class="language-php">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
</code></pre>
<p>8、配置www.conf，配置用户的文件</p>
<pre><code class="language-php">cp /usr/local/php/etc/php-fpm.d/www.conf.default  /usr/local/php/etc/php-fpm.d/www.conf
</code></pre>
<p>9、将php-fpm启动文件复制到init.d文件夹中一份方便启动php</p>
<pre><code class="language-php">cp /usr/local/php/sbin/php-fpm /etc/init.d/php-fpm
</code></pre>
<p>10、启动php，确定是否安装成功</p>
<pre><code class="language-php">执行命令/etc/init.d/php-fpm即可
查看是否启动：ps -ef | grep php既可以看到php启动了哪些进程
</code></pre>
<h2 id="二-简化php执行命令">二、简化php执行命令</h2>
<p>查看php版本：/usr/local/php/bin/php -v<br>
简化后：php -v<br>
执行php文件：/usr/local/php/bin/php test.php<br>
简化后：php test.php</p>
<p><strong>开始简化处理：</strong><br>
执行命令：vi ~/.bash_profile<br>
<img src="https://img-blog.csdnimg.cn/20201102175325289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70#pic_center" alt="!在这里插入图片描述(https://img-blog.csdnimg.cn/2020110217485461.png#pic_cente" loading="lazy"><br>
在export PATH下添加</p>
<pre><code class="language-php">alias php=/usr/local/php/bin/php
</code></pre>
<p>之后保存退出，执行以下命令</p>
<pre><code class="language-php">source ~/.bash_profile 
</code></pre>
<p>之后执行php -v 查看是否设置成功，成功会跳出php版本信息</p>
<h2 id="三-安装成功后配置nginx支持php">三、安装成功后配置nginx支持php</h2>
<p>1、更改php.ini文件 vi /usr/local/php/lib/php.ini</p>
<p>通过查找cgi.fix_pathinfo=1这个配置，并去除注释，并改为cgi.fix_pathinfo=0，这里并不属于nginx支持php配置相关，而是专属于nginx下php的一个安全漏洞，如果这里值为1，用户方可以通过上传图片来上传木马，然后通过url访问该图片地址，并在地址后加入/xxx.php将该图片作为php文件运行，这是只有在nginx里才会存在的问题，apache和iis都没有该问题</p>
<p><em>以上问题可以直接参看鸟哥的博客，写的相当详细：http://www.laruence.com/2010/05/20/1495.html</em></p>
<p>2、配置web专用的组和用户<br>
添加www用户组：groupadd www<br>
添加www用户组下的用户www：useradd -g www www</p>
<p>3、更改php-fpm.conf配置<br>
将user=nobody的注释去掉，并将nobody改成上面配置的www用户<br>
将group=nobody的注释去掉，并将nobody改成上面配置的www用户组<br>
最后检查php-fpm.conf最后的include的值是不是正确的www.conf目录地址，如果不正确则换成正确的目录地址。</p>
<p>4）更改www.conf配置</p>
<p>将user=nobody的注释去掉，并将nobody改成上面配置的www用户</p>
<p>将group=nobody的注释去掉，并将nobody改成上面配置的www用户组</p>
<p>5）更改nginx.conf文件 /etc/local/nginx/conf/nginx.conf</p>
<p>将#user=nobody去掉注释并改为user=www</p>
<p>去除 location ~ .php<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><mi mathvariant="normal">这</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">释</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">将</mi><mi>f</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>c</mi><mi>g</mi><msub><mi>i</mi><mi>p</mi></msub><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">为</mi></mrow><annotation encoding="application/x-tex">{...}这段代码的注释，并将fastcgi_param里的/scripts改为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">释</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">将</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">为</span></span></span></span>document_root<br>
<img src="https://img-blog.csdnimg.cn/20201103110342119.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>最后将location / {...}里默认index后面添加上index.php，确保index.php作为默认的首页</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201103110356804.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>6）重启php-fpm和nginx，可以<code>killall php-fpm</code>然后再<code>/etc/init.d/php-fpm start</code><br>
即可启动，<code>/usr/local/nginx/sbin/nginx -s stop</code>即可停止nginx，然后执行<code>/usr/local/nginx/sbin/nginx -s reload</code>即可重启。</p>
<p>7）在html目录里随便创建一个php文件，内容是phpinfo();，然后在浏览器中访问该文件地址，看是否得到正确的php相关信息，如果正确显示则配置成功。</p>
<h2 id="nginx自定义域名">nginx自定义域名</h2>
<pre><code class="language-php">vim /usr/local/nginx/conf/nginx.conf
</code></pre>
<p>在 http下的 gzip on下添加如下代码，添加之后保存退出</p>
<pre><code class="language-php">include vhosts/*.conf
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210422174530119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
创建自定义域名的配置文件夹</p>
<pre><code class="language-php">mkdir /usr/local/nginx/conf/vhosts
</code></pre>
<p>新建 test.io_8888.conf 配置文件</p>
<pre><code class="language-php">vim /usr/local/nginx/conf/vhosts/test.io_8888.conf
</code></pre>
<p>添加如下代码，然后保存退出</p>
<pre><code class="language-php">
server {
        listen       8888;
        server_name  test.io;
        root   &quot;/home/www/test/public&quot;;
        location / {
            index index.php index.html error/index.html;
            include /home/www/test/public/nginx.htaccess;
            autoindex  off;
        }
        location ~ \.php(.*)$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            fastcgi_param  PATH_INFO  $fastcgi_path_info;
            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;
            include        fastcgi_params;
        }
}

</code></pre>
<p>之后重启nginx</p>
<pre><code class="language-php">/usr/local/nginx/sbin/nginx -s reload
</code></pre>
<p>在hosts里添加对应的ip和域名，然后浏览器访问test.io:8888即可</p>
<pre><code class="language-php">192.168.153.128 test.io
</code></pre>
<h2 id="三-下载swoole">三、下载swoole</h2>
<p>1、通过git clone git@github.com:swoole/swoole-src.git<br>
2、直接下载压缩包</p>
<p>打开解压后的swoole，如果没有configure文件，可通过执行： /usr/local/php/bin/phpize来生成</p>
<p>之后执行</p>
<pre><code class="language-php">./configure --with-php-config=/usr/local/php/bin/php-config
</code></pre>
<p>然后</p>
<pre><code class="language-php">make
</code></pre>
<pre><code class="language-php">make install
</code></pre>
<p>完成。</p>
<h2 id="四-测试swoole">四、测试swoole</h2>
<p>1、然后在/root/swoole/swoole-src/examples/server下找一个例子执行<br>
例如：</p>
<pre><code class="language-php">php echo.php
</code></pre>
<p>之后会报错<br>
<img src="https://img-blog.csdnimg.cn/20201103161718507.png#pic_center" alt="PHP Fatal error:  Uncaught Error: Class 'swoole_server' not found in /root/swoole/swoole-src/examples/server/echo.php:2" loading="lazy"></p>
<p>2、接着修改php.ini（完整路径/usr/local/php/lib/php.ini）文件，添加extension=swoole<br>
<img src="https://img-blog.csdnimg.cn/2020110316290544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy">3、然后保存退出，接着重新回到第一点，就不会报错了。换到另一个窗口查看进程：netstat -anp | grep 9501<br>
<img src="https://img-blog.csdnimg.cn/20201103163718933.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="五-安装redis">五、安装redis</h2>
<p>1、redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（gcc -v），如果没有安装，执行以下命令进行安装。</p>
<pre><code class="language-php">yum install -y gcc
</code></pre>
<p>2、下载并解压安装包</p>
<pre><code class="language-php">wget http://download.redis.io/releases/redis-5.0.7.tar.gz
tar -zxvf redis-5.0.7.tar.gz
</code></pre>
<p>3、cd切换到redis解压目录下，执行编译</p>
<pre><code class="language-php">cd redis-5.0.7 &amp;&amp; make
</code></pre>
<p>4、安装并指定安装目录</p>
<pre><code class="language-php">make install PREFIX=/usr/local/redis
</code></pre>
<p>5、启动服务</p>
<blockquote>
<p>前台启动</p>
</blockquote>
<pre><code class="language-php">cd /usr/local/redis/bin/
./redis-server
</code></pre>
<blockquote>
<p>后台启动</p>
</blockquote>
<p>从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录</p>
<pre><code class="language-php">cp /usr/local/redis-5.0.7/redis.conf /usr/local/redis/bin/
</code></pre>
<p>修改 redis.conf 文件，把 daemonize no 改为 daemonize yes</p>
<pre><code class="language-php">vim redis.conf
</code></pre>
<p>启动</p>
<pre><code class="language-php">./redis-server redis.conf
</code></pre>
<p>6、设置开机启动</p>
<pre><code class="language-php">vim /etc/systemd/system/redis.service
</code></pre>
<p>添加如下内容</p>
<pre><code class="language-php">[Unit]
Description=redis-server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf

PrivateTmp=true
[Install]
WantedBy=multi-user.target
</code></pre>
<p>注意：<code>ExecStart</code> 配置成自己的路径</p>
<p>设置开机启动</p>
<pre><code class="language-php">systemctl daemon-reload
systemctl start redis.service
systemctl enable redis.service
</code></pre>
<p>创建 redis 命令软链接</p>
<pre><code class="language-php">ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis
# 测试
redis
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt;
</code></pre>
<p>常用命令</p>
<pre><code class="language-php"># 启动redis服务
systemctl start redis.service
# 停止redis服务
systemctl stop redis.service
# 重新启动服务
systemctl restart redis.service
# 查看服务当前状态
systemctl status redis.service
# 设置开机自启动
systemctl enable redis.service
# 停止开机自启动
systemctl disable redis.service
</code></pre>
<blockquote>
<p>php支持redis</p>
</blockquote>
<pre><code class="language-php">wget http://pecl.php.net/get/redis-5.3.4.tgz

tar -zxvf redis-5.3.4.tgz

cd redis-5.3.4

/usr/local/php/bin/phpize　　　　　　　#用phpize生成./configure

./configure --with-php-config=/usr/local/php/bin/php-config 　　#配置

make

make  install

#配置php.ini文件，使得php可以使用redis扩展　　
vim  /usr/local/php/etc/php.ini

#在extension任意位置添加如下代码
extension=redis.so
#保存退出，重启php-fpm，通过phpinfo()查看是否安装成功redis扩展

</code></pre>
<h2 id="六-mysql">六、Mysql</h2>
<p>文件下载到Centos/usr/local/mysql文件夹下；</p>
<pre><code class="language-php">cd /usr/local
mkdir mysql
cd mysql
wget  https://repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm
</code></pre>
<p>安装 yum repo文件并更新 yum 缓存</p>
<pre><code class="language-php">rpm -ivh mysql80-community-release-el7-1.noarch.rpm
</code></pre>
<p>执行结果：<br>
会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo<br>
更新 yum 命令</p>
<pre><code class="language-php">yum clean all
yum makecache
</code></pre>
<p>使用 yum安装mysql<br>
当我们在使用yum安装mysql时，yum默认会从yum仓库中安装mysql最新的GA版本；如何选择自己的版本；</p>
<p>第一步： 查看mysql yum仓库中mysql版本，使用如下命令</p>
<pre><code class="language-php">yum repolist all | grep mysql
</code></pre>
<p>第二步 使用 yum-config-manager 命令修改相应的版本为启用状态最新版本为禁用状态，根据需要安装的版本修改</p>
<pre><code class="language-php">yum-config-manager --disable mysql57-community #关闭5.7版本
yum-config-manager --enable mysql80-community #开启8.0版本

#如果报yum-config-manager命令不存在，就执行如下命令
yum -y install yum-utils
</code></pre>
<blockquote>
<p>或者可以编辑 mysql repo文件，<br>
cat /etc/yum.repos.d/mysql-community.repo<br>
将相应版本下的enabled改成 1 即可；</p>
</blockquote>
<p>安装mysql 命令如下：</p>
<pre><code class="language-php">yum install mysql-community-server
</code></pre>
<p>开启mysql 服务</p>
<pre><code class="language-php">systemctl start mysqld.service
</code></pre>
<p>获取初始密码登录mysql<br>
mysql在安装后会创建一个root@locahost账户，并且把初始的密码放到了/var/log/mysqld.log文件中；</p>
<pre><code class="language-php">cat /var/log/mysqld.log | grep password
</code></pre>
<p>使用初始密码登录mysql</p>
<pre><code class="language-php"> #会提示输入密码
mysql -u root -p 

#回车之后报：
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
</code></pre>
<p>忘记密码or重置密码</p>
<pre><code class="language-php"> #注：windows下修改的是my.ini
vim /etc/my.cnf

# 在[mysqld]后面任意一行添加skip-grant-tables用来跳过密码验证的过程，设置完密码记得删除
skip-grant-tables

#重启mysql ，就可以免密码登陆了，然后进行修改密码
systemctl restart mysqld.service 

#然后重新登录
mysql -u root -p 
</code></pre>
<p>在安装Mysql8.0.3过程中重置密码时报了这个错误, 原因是没有设置密码时需要在/etc/my.cnf中添加这段时才能操作mysql<br>
#跳过密码验证<br>
skip-grant-tables<br>
但是添加完这句后操作mysql又报了这个错误, 这就成了一个死循环, 最后发现了解决办法,<br>
这是因为权限设置了但还没有刷新导致的。<br>
先执行</p>
<pre><code class="language-php">flush privileges;
</code></pre>
<p>然后修改密码：</p>
<pre><code class="language-php">#注意位数和种类至少大写+小写+符号+数字
ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';
或
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
</code></pre>
<p>密码策略问题异常信息：<br>
<img src="https://img-blog.csdnimg.cn/20210423120124634.png" alt="在这里插入图片描述" loading="lazy"><br>
解决办法：<br>
1、查看 mysql 初始的密码策略，输入语句以下进行查看</p>
<pre><code class="language-php">SHOW VARIABLES LIKE 'validate_password%';
</code></pre>
<p>2、首先需要设置密码的验证强度等级，设置 validate_password.policy 的全局参数为 LOW 即可</p>
<pre><code class="language-php">set global validate_password.policy=LOW;
</code></pre>
<p>3、当前密码长度为 8，设置 validate_password.length  的全局参数为你想要的密码长度即可</p>
<pre><code class="language-php">set global validate_password.length = 6;
</code></pre>
<p>查看密码验证强度和密码长度是否都设置成功，如下图<br>
<img src="https://img-blog.csdnimg.cn/20210423122319298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关于上图 mysql 密码策略相关参数：</p>
<pre><code class="language-php">+--------------------------------------+-------+
| Variable_name                        | Value |
+--------------------------------------+-------+
| validate_password.check_user_name    | ON    |检查用户名
| validate_password.dictionary_file    |       |指定密码验证的文件路径
| validate_password.length             | 6     |固定密码的总长度
| validate_password.mixed_case_count   | 0     |整个密码中至少要包含大/小写字母的总个数
| validate_password.number_count       | 0     |整个密码中至少要包含阿拉伯数字的个数
| validate_password.policy             | LOW   |指定密码的强度验证等级，默认为 MEDIUM
| validate_password.special_char_count | 0     |整个密码中至少要包含特殊字符的个数
+--------------------------------------+-------+
关于 validate_password.policy 的取值：
0/LOW：只验证长度;
1/MEDIUM：验证长度、数字、大小写、特殊字符;
2/STRONG：验证长度、数字、大小写、特殊字符、字典文件;
</code></pre>
<p>常用mysql服务命令：</p>
<pre><code class="language-php">mysql -u username -p #登录mysql
quit #退出mysql 
systemctl start mysqld.service  #启动mysql
systemctl stop mysqld.service #结束
systemctl restart mysqld.service #重启
systemctl enable mysqld.service #开机自启
mysql --version 或 mysql -V #查看mysql版本
</code></pre>
<p>设置mysql允许远程连接<br>
1.登录mysql，命令：<code>mysql -u root -p</code> 然后输入密码即可<br>
2.使用mysql库：<code>use mysql;</code><br>
3.查询信息：<code>select user,host from user;</code><br>
4.修改root用户的host字段：<code>update user set host=&quot;%&quot; where user=&quot;root&quot;;</code><br>
5.使本次修改立即生效：<code>flush privileges;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vmware虚拟机中的linux怎么和windows主机做目录映射]]></title>
        <id>https://oackrevv.github.io/post/Fxv_ae_jX/</id>
        <link href="https://oackrevv.github.io/post/Fxv_ae_jX/">
        </link>
        <updated>2022-10-28T03:19:49.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210421150938898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
1、安装open-vm-tools</p>
<pre><code class="language-php"> yum install open-vm-tools open-vm-tools-desktop
</code></pre>
<p>2、用vmtools挂载共享目录</p>
<pre><code class="language-php">vmware-hgfsclient  //查看共享的目录
</code></pre>
<pre><code class="language-php">vmhgfs-fuse .host:/VMShare /mnt/hgfs -o allow_other,uid=0,gid=0 
</code></pre>
<p>这里一定要加-o后面的部分，否则nginx访问共享目录可能出现403，但是后面的开机自启动配置是有配置的)进行手动挂载，其中VMShare是共享文件夹名，/mnt/hgfs是挂载目录名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cmd 操作数据库]]></title>
        <id>https://oackrevv.github.io/post/JEuYaGPdz/</id>
        <link href="https://oackrevv.github.io/post/JEuYaGPdz/">
        </link>
        <updated>2022-10-28T03:13:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cmd-操作数据库">cmd 操作数据库</h2>
<pre><code>    1、链接到MYSQL数据库：mysql -h -u -p;//h是指服务器，u是指用户，p是指密码
    2、查看所有数据库：show databases;
    3、选择一个数据库：use databasename;
    4、查看所选择数据库里的所有表：show tables;
    5、查看这个表的字段结构：desc tablename;
    6、查看这个表的所有字段数据：select * from tablename;
</code></pre>
<h2 id="连表">连表</h2>
<pre><code>	只返回两张表匹配的记录，这叫内连接（inner join）。
	返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）。
	返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）。
	返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）。
</code></pre>
<h2 id="存储过程">存储过程</h2>
<pre><code>查看event是否开启
show variables like '%sche%'; 
将事件计划开启
set global event_scheduler=1; 
关闭事件任务
alter event e_test ON COMPLETION PRESERVE DISABLE; 
开启事件任务:
alter event e_test ON COMPLETION PRESERVE ENABLE; 

## 创建存储过程
DROP PROCEDURE IF EXISTS update_top;
CREATE PROCEDURE update_top ( ) BEGIN
	UPDATE attract_work SET is_top = 0,top_time = NULL,top_expire_time = NULL WHERE top_expire_time &lt;= NOW( );
END

## 创建事件并触发
CREATE EVENT update_top_event ON SCHEDULE EVERY 1 SECOND STARTS NOW( ) ON COMPLETION PRESERVE DO
CALL update_top ( )

## 事件不执行，查看是否开启了event_scheduler
 SHOW VARIABLES LIKE 'event_scheduler'
 // 开启event_scheduler
 set global event_scheduler = on;
</code></pre>
<h2 id="解决-sql_modeonly_full_group_by">解决 sql_mode=only_full_group_by</h2>
<p>出现这个问题主要是和mysql中SQL模式中的only_full_group_by有关，在mysql5.7之前的版本，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的，在mysql5.7中only_full_group_by 默认是启用的，所以MySQL会拒绝选择列表、条件或顺序列表引用的查询，这些查询将引用组中未命名的非聚合列，而不是在功能上依赖于它们。</p>
<p>查看当前mysql的sql模式，执行以下个命令，可以查看 sql_mode 的内容。</p>
<pre><code class="language-php">mysql&gt; SHOW SESSION VARIABLES;
mysql&gt; SHOW GLOBAL VARIABLES;
mysql&gt; select @@sql_mode;
</code></pre>
<p>出现only_full_group_by这个意味着sql模式启用了，将它去掉就不会有报错了。<br>
<img src="https://img-blog.csdnimg.cn/20191116142546793.png" alt="在这里插入图片描述" loading="lazy"><br>
1、执行sql语句修改sql_mode的值</p>
<pre><code class="language-php">mysql&gt; set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
 
mysql&gt; set session sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
</code></pre>
<p>缺点：设置完成以后，如果重启mysql服务，还是会依然报这个错误。所以推荐使用第二种方式。</p>
<p>2、找到mysql的配置文件<br>
<img src="https://img-blog.csdnimg.cn/20191116143136289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
打开并增加以下语句</p>
<pre><code class="language-php">sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2019111614332532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
然后重启mysql即可。</p>
<h2 id="查询每天的总数">查询每天的总数</h2>
<pre><code class="language-sql">SELECT DATE_FORMAT(FROM_UNIXTIME(last_addtime),&quot;%Y-%m-%d&quot;) as date,count(*) as total FROM `zs_client` WHERE  `source_id` &lt;&gt; 0  AND `guishu_school_id` &lt;&gt; 0  AND `last_addtime` BETWEEN 1593532800 AND 1596211199 GROUP BY `date`

Db::name('client')-&gt;where($where)-&gt;field('DATE_FORMAT(FROM_UNIXTIME(last_addtime),&quot;%Y-%m-%d&quot;) as date,count(*) as total')-&gt;group('date')-&gt;select();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[非常全的Linux常用命令]]></title>
        <id>https://oackrevv.github.io/post/FCF827sIY/</id>
        <link href="https://oackrevv.github.io/post/FCF827sIY/">
        </link>
        <updated>2022-10-28T03:08:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>系统信息
arch 显示机器的处理器架构(1)
uname -m 显示机器的处理器架构(2)
uname -r 显示正在使用的内核版本
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
hdparm -i /dev/hda 罗列一个磁盘的架构特性
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作
cat /proc/cpuinfo 显示CPU info的信息
cat /proc/interrupts 显示中断
cat /proc/meminfo 校验内存使用
cat /proc/swaps 显示哪些swap被使用
cat /proc/version 显示内核的版本
cat /proc/net/dev 显示网络适配器及统计
cat /proc/mounts 显示已加载的文件系统
lspci -tv 罗列 PCI 设备
lsusb -tv 显示 USB 设备
date 显示系统日期
cal 2007 显示2007年的日历表
date 041217002007.00 设置日期和时间 - 月日时分年.秒
clock -w 将时间修改保存到 BIOS

关机 (系统的关机、重启以及登出 )
shutdown -h now 关闭系统(1)
init 0 关闭系统(2)
telinit 0 关闭系统(3)
shutdown -h hours:minutes &amp; 按预定时间关闭系统
shutdown -c 取消按预定时间关闭系统
shutdown -r now 重启(1)
reboot 重启(2)
logout 注销

文件和目录
cd /home 进入 '/ home' 目录'
cd .. 返回上一级目录
cd ../.. 返回上两级目录
cd 进入个人的主目录
cd ~user1 进入个人的主目录
cd - 返回上次所在的目录
pwd 显示工作路径
ls 查看目录中的文件
ls -F 查看目录中的文件
ls -l 显示文件和目录的详细资料
ls -a 显示隐藏文件
ls *[0-9]* 显示包含数字的文件名和目录名
tree 显示文件和目录由根目录开始的树形结构(1)
lstree 显示文件和目录由根目录开始的树形结构(2)
mkdir dir1 创建一个叫做 'dir1' 的目录'
mkdir dir1 dir2 同时创建两个目录
mkdir -p /tmp/dir1/dir2 创建一个目录树
rm -f file1 删除一个叫做 'file1' 的文件'
rmdir dir1 删除一个叫做 'dir1' 的目录'
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容
rm -rf dir1 dir2 同时删除两个目录及它们的内容
mv dir1 new_dir 重命名/移动 一个目录
cp file1 file2 复制一个文件
cp dir/* . 复制一个目录下的所有文件到当前工作目录
cp -a /tmp/dir1 . 复制一个目录到当前工作目录
cp -a dir1 dir2 复制一个目录
ln -s file1 lnk1 创建一个指向文件或目录的软链接
ln file1 lnk1 创建一个指向文件或目录的物理链接
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)
file file1 outputs the mime type of the file as text
iconv -l 列出已知的编码
iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.
find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)

文件搜索
find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 'user1' 的文件和目录
find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件
find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限
find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备
locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令
whereis halt 显示一个二进制文件、源码或man的位置
which halt 显示一个二进制文件或可执行文件的完整路径

挂载一个文件系统
mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出
fuser -km /mnt/hda2 当设备繁忙时强制卸载
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用
mount /dev/fd0 /mnt/floppy 挂载一个软盘
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享

磁盘空间
df -h 显示已经挂载的分区列表
ls -lSr |more 以尺寸大小排列文件和目录
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)
dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)

用户和群组
groupadd group_name 创建一个新用户组
groupdel group_name 删除一个用户组
groupmod -n new_group_name old_group_name 重命名一个用户组
useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户
useradd user1 创建一个新用户
userdel -r user1 删除一个用户 ( '-r' 排除主目录)
usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性
passwd 修改口令
passwd user1 修改一个用户的口令 (只允许root执行)
chage -E 2005-12-31 user1 设置用户口令的失效期限
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组

文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消
ls -lh 显示权限
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限
chown user1 file1 改变一个文件的所有人属性
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性
chgrp group1 file1 改变文件的群组
chown user1:group1 file1 改变一个文件的所有人和群组属性
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的
chmod g-s /home/public 禁用一个目录的 SGID 位
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件
chmod o-t /home/public 禁用一个目录的 STIKY 位

文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消
chattr +a file1 只允许以追加方式读写文件
chattr +c file1 允许这个文件能被内核自动压缩/解压
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接
chattr +s file1 允许一个文件被安全地删除
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件
lsattr 显示特殊的属性

打包和压缩文件
bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件
bzip2 file1 压缩一个叫做 'file1' 的文件
gunzip file1.gz 解压一个叫做 'file1.gz'的文件
gzip file1 压缩一个叫做 'file1'的文件
gzip -9 file1 最大程度压缩
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'
rar x file1.rar 解压rar包
unrar x file1.rar 解压rar包
tar -cvf archive.tar file1 创建一个非压缩的 tarball
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件
tar -tf archive.tar 显示一个包中的内容
tar -xvf archive.tar 释放一个包
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包
zip file1.zip file1 创建一个zip格式的压缩包
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包
unzip file1.zip 解压一个zip格式压缩包

RPM 包 - （Fedora, Redhat及类似系统）
rpm -ivh package.rpm 安装一个rpm包
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告
rpm -U package.rpm 更新一个rpm包但不改变其配置文件
rpm -F package.rpm 更新一个确定已经安装的rpm包
rpm -e package_name.rpm 删除一个rpm包
rpm -qa 显示系统中所有已经安装的rpm包
rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包
rpm -qi package_name 获取一个已安装包的特殊信息
rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表
rpm -q package_name --whatprovides 显示一个rpm包所占的体积
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l
rpm -q package_name --changelog 显示一个rpm包的修改历史
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书
rpm --checksig package.rpm 确认一个rpm包的完整性
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间
rpm -Va 检查系统中所有已安装的rpm包- 小心使用
rpm -Vp package.rpm 确认一个rpm包还未安装
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包

YUM 软件包升级器 - （Fedora, RedHat及类似系统）
yum install package_name 下载并安装一个rpm包
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系
yum update package_name.rpm 更新当前系统中所有安装的rpm包
yum update package_name 更新一个rpm包
yum remove package_name 删除一个rpm包
yum list 列出当前系统中安装的所有包
yum search package_name 在rpm仓库中搜寻软件包
yum clean packages 清理rpm缓存删除下载的包
yum clean headers 删除所有头文件
yum clean all 删除所有缓存的包和头文件

DEB 包 (Debian, Ubuntu 以及类似系统)
dpkg -i package.deb 安装/更新一个 deb 包
dpkg -r package_name 从系统删除一个 deb 包
dpkg -l 显示系统中所有已经安装的 deb 包
dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供

APT 软件工具 (Debian, Ubuntu 以及类似系统)
apt-get install package_name 安装/更新一个 deb 包
apt-cdrom install package_name 从光盘安装/更新一个 deb 包
apt-get update 升级列表中的软件包
apt-get upgrade 升级所有已安装的软件
apt-get remove package_name 从系统删除一个deb包
apt-get check 确认依赖的软件仓库正确
apt-get clean 从下载的软件包中清理缓存
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称

查看文件内容
cat file1 从第一个字节开始正向查看文件的内容
tac file1 从最后一行开始反向查看一个文件的内容
more file1 查看一个长文件的内容
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作
head -2 file1 查看一个文件的前两行
tail -2 file1 查看一个文件的最后两行
tail -f /var/log/messages 实时查看被添加到一个文件中的内容

文本处理
cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT
cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中
cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中
grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词&quot;Aug&quot;
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以&quot;Aug&quot;开始的词汇
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串&quot;Aug&quot;
sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;
sed '/^$/d' example.txt 从example.txt文件中删除所有空白行
sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容
sed -e '1d' result.txt 从文件example.txt 中排除第一行
sed -n '/stringa1/p' 查看只包含词汇 &quot;string1&quot;的行
sed -e 's/ *$//' example.txt 删除每一行最后的空白字符
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容
sed -n '5p;5q' example.txt 查看第5行
sed -e 's/00*/0/g' example.txt 用单个零替换多个零
cat -n file1 标示文件的行数
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行
echo a b c | awk '{print $1}' 查看一行第一栏
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏
paste file1 file2 合并两个文件或两栏的内容
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分
sort file1 file2 排序两个文件的内容
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)
sort file1 file2 | uniq -u 删除交集，留下其他的行
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分

字符设置和文件格式转换
dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS
recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html
recode -l | more 显示所有允许的转换格式

文件系统分析
badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性

初始化一个文件系统
mkfs /dev/hda1 在hda1分区创建一个文件系统
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统
fdformat -n /dev/fd0 格式化一个软盘
mkswap /dev/hda3 创建一个swap文件系统

SWAP文件系统
mkswap /dev/hda3 创建一个swap文件系统
swapon /dev/hda3 启用一个新的swap文件系统
swapon /dev/hda2 /dev/hdb3 启用两个swap分区

备份
dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份
restore -if /tmp/home0.bak 还原一个交互式备份
rsync -rogpav --delete /home /tmp 同步两边的目录
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作
( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个目录内容
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个本地目录
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容

光盘
cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容
mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件
mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件
mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中
cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3）
cdrecord --scanbus 扫描总线以识别scsi通道
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD

网络 - （以太网和WIFI无线）
ifconfig eth0 显示一个以太网卡的配置
ifup eth0 启用一个 'eth0' 网络设备
ifdown eth0 禁用一个 'eth0' 网络设备
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)
dhclient eth0 以dhcp模式启用 'eth0'
route -n show routing table
route add -net 0/0 gw IP_Gateway configura default gateway
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'
route del 0/0 gw IP_gateway remove static route
echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing
hostname show hostname of system
host www.example.com lookup hostname to resolve name to ip address and viceversa(1)
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)
ip link show show link status of all interfaces
mii-tool eth0 show link status of 'eth0'
ethtool eth0 show statistics of network card 'eth0'
netstat -tup show all active network connections and their PID
netstat -tupl show all network services listening on the system and their PID
tcpdump tcp port 80 show all HTTP traffic
iwlist scan show wireless networks
iwconfig eth1 show configuration of a wireless network card
hostname show hostname
host www.example.com lookup hostname to resolve name to ip address and viceversa
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa
whois www.example.com lookup on Whois database

 

JPS工具

jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。

我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。

使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。

jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.

$&gt; jps
23991 Jps
23789 BossMain
23651 Resin

 

比较常用的参数：

-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
$&gt;  jps -q
28680
23789
23651

-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null

$&gt; jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log

-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名

$&gt; jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin

-v 输出传递给JVM的参数

$&gt; jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl

sudo jps看到的进程数量最全

jps 192.168.0.77

列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099

（前提是远程服务器提供jstatd服务）

注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[code]]></title>
        <id>https://oackrevv.github.io/post/nemTv-LYR/</id>
        <link href="https://oackrevv.github.io/post/nemTv-LYR/">
        </link>
        <updated>2022-10-28T03:07:45.000Z</updated>
        <content type="html"><![CDATA[<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .paging{width: 100%;height: auto;text-align: center;margin-top: 40px;margin-bottom: 40px;}
        .paging li{display: inline-block;padding: 5px 10px;margin: 0 5px;}
        .paging .active a{color: white;}
        .paging .active{background: #13aaf6;border-color: #13aaf6;}
        .paging li a{display: block;color: #434343;font-size: 16px;}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;/body&gt;
&lt;/html&gt;
&lt;?php
function handlePaging($count=0,$limit=10,$page=1,$param=[]){
    if($count &lt; $limit){
        $totalPage = 1;//如果总记录数小于每页的页数，那么只有一页
    }else if($count % $limit){
        $totalPage = (int)($count/$limit)+1;//如果有余数，则总记录数除以每页的页数并加一页
    }else{
        $totalPage = (int)$count/$limit;//如果没有余数，则总记录数除以每页的页数
    }
    $startPage = 1;//默认开始页
    $middlePage = 10;//中间要显示多少页
    $endPage = $totalPage;//默认结束页
    $pageOffset = ceil(($middlePage-1)/2);//计算偏移量
    if($totalPage &gt; $middlePage){
        if($page &gt; $pageOffset){
            $startPage = $page - $pageOffset;
            $endPage = $totalPage &gt; $page + $pageOffset ? $page + $pageOffset : $totalPage;
        }else{
            $startPage = 1;
            $endPage = $totalPage &gt; $middlePage ? $middlePage : $totalPage;
        }
        if($page + $pageOffset &gt; $totalPage){
            $startPage = $startPage - ($page + $pageOffset - $endPage);
        }
    }
    // 链接参数处理
    $urlParam = '';
    if(!empty($param)){
        foreach ($param as $k =&gt; $v){
            if($param[$k] != ''){
                if($urlParam != ''){
                    $urlParam .= &quot;&amp;{$k}={$v}&quot;;
                }else{
                    $urlParam .= &quot;?{$k}={$v}&quot;;
                }
            }
        }
    }
    // 上一页
    if($page == 1){
        $href = 'javascript:void(0)';
    }else{
        $p = $page-1 &lt; 1 ? 1 : $page-1;
        if($urlParam != ''){
            $href = &quot;{$urlParam}&amp;page={$p}&quot;;
        }else{
            $href = &quot;?page={$p}&quot;;
        }
    }
    $pageStr = &quot;&lt;li&gt;&lt;a href='{$href}'&gt;上一页&lt;/a&gt;&lt;/li&gt;&quot;;
    // 中间页
    for ($i=$startPage; $i &lt;= $endPage; $i++) {
        $active = '';
        if($page == $i) {
            $active = 'class=&quot;active&quot;';//选中当前页
        }
        if($urlParam != ''){
            $href = &quot;{$urlParam}&amp;page={$i}&quot;;
        }else{
            $href = &quot;?page={$i}&quot;;
        }
        $pageStr .= &quot;&lt;li $active&gt;&lt;a href='{$href}'&gt;{$i}&lt;/a&gt;&lt;/li&gt;&quot;;
    }
    // 下一页
    if($page == $totalPage){
        $href = 'javascript:void(0)';
    }else{
        $p = $page+1 &gt; $totalPage ? $totalPage : $page+1;
        if($urlParam != ''){
            $href = &quot;{$urlParam}&amp;page={$p}&quot;;
        }else{
            $href = &quot;?page={$p}&quot;;
        }
    }
    $pageStr .= &quot;&lt;li&gt;&lt;a href='{$href}'&gt;下一页&lt;/a&gt;&lt;/li&gt;&quot;;
    $str      = &quot;&lt;div class='paging'&gt;&lt;ul&gt;{$pageStr}&lt;/ul&gt;&lt;/div&gt;&quot;;
    return $str;
}
echo handlePaging(120,10,$_GET['page']??1);
echo &quot;&lt;hr&gt;&quot;;
if(function_exists('random_int')){
	$clockSeq = random_int(0, 0x3fff);
}else{
	$clockSeq = mt_rand(0,0x3fff);
	
}
print_r($clockSeq);
echo &quot;&lt;hr&gt;&quot;;


/*php经典趣味算法*/

echo '1、一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。&lt;br&gt;';
function king($n, $m){
    $monkeys = range(1, $n);         //创建1到n数组
    $i=0;
    while (count($monkeys)&gt;1) {   //循环条件为猴子数量大于1
        if(($i+1)%$m==0) {   //$i为数组下标;$i+1为猴子标号
            unset($monkeys[$i]);    //余数等于0表示正好第m个，删除，用unset删除保持下标关系
        } else {
            array_push($monkeys,$monkeys[$i]);     //如果余数不等于0，则把数组下标为$i的放最后，形成一个圆形结构
            unset($monkeys[$i]);
        }
        $i++;//$i 循环+1，不断把猴子删除，或 push到数组 
    }
    return current($monkeys);   //猴子数量等于1时输出猴子标号，得出猴王
}
echo king(6,3);
echo &quot;&lt;hr&gt;&quot;;

echo '2、有一母牛，到4岁可生育，每年一头，所生均是一样的母牛，到15岁绝育，不再能生，20岁死亡，问n年后有多少头牛。&lt;br&gt;';
function niu($y){
    static $num= 1;                 //定义静态变量;初始化牛的数量为1
    for ($i=1; $i &lt;=$y ; $i++) {     
	    if($i&gt;=4 &amp;&amp; $i&lt;15){         //每年递增来算，4岁开始+1，15岁不能生育
	        $num++;
	        niu($y-$i);             //递归方法计算小牛$num，小牛生长年数为$y-$i
	    }else if($i==20){           
	   		$num--;                //20岁死亡减一
	    }
	}
    return $num;
}
echo niu(5);
echo &quot;&lt;hr&gt;&quot;;

echo '3、杨辉三角&lt;br&gt;';
/* 默认输出十行，用T(值)的形式可改变输出行数 */
class T{
  private $num;
  public function __construct($var=10) {
    if ($var&lt;3) die(&quot;值太小啦！&quot;);
    $this-&gt;num=$var;
  }
  public function display(){
    $n=$this-&gt;num;
    $arr=array();
  //$arr=array_fill(0,$n+1,array_fill(0,$n+1,0));
    $arr[1]=array_fill(0,3,0);
    $arr[1][1]=1;
    echo str_pad(&quot; &quot;,$n*12,&quot; &quot;);
    printf(&quot;%3d&quot;,$arr[1][1]);
    echo &quot;&lt;br/&gt;&quot;;
    for($i=2;$i&lt;=$n;$i++){
      $arr[$i]=array_fill(0,($i+2),0);
      for($j=1;$j&lt;=$i;$j++){
        if($j==1)
          echo str_pad(&quot; &quot;,($n+1-$i)*12,&quot; &quot;);
        printf(&quot;%3d&quot;,$arr[$i][$j]=$arr[$i-1][$j-1]+$arr[$i-1][$j]);
        echo &quot;  &quot;;
      }
      echo&quot;&lt;br/&gt;&quot;;
    }
  }
}
$yh=new T('3'); //$yh=new T(数量);
$yh-&gt;display();
echo &quot;&lt;hr&gt;&quot;;

echo '4、冒泡排序&lt;br&gt;';
function maopao($arr){
    $len = count($arr);
    for($k=0;$k&lt;=$len;$k++){
        for($j=$len-1;$j&gt;$k;$j--){
          if($arr[$j]&lt;$arr[$j-1]){
            $temp = $arr[$j];
            $arr[$j] = $arr[$j-1];
            $arr[$j-1] = $temp;
          }
        }
    }
    return $arr;
}
print_r(maopao([3,5,8,6,1,2,7,4,10,9]));
echo &quot;&lt;hr&gt;&quot;;

echo '5、快速排序&lt;br&gt;';
function quickSort($arr) {
    //先判断是否需要继续进行
    $length = count($arr);
    if($length &lt;= 1) {
        return $arr;
    }
    //选择第一个元素作为基准
    $base_num = $arr[0];
    //遍历除了标尺外的所有元素，按照大小关系放入两个数组内
    //初始化两个数组
    $left_array = array();  //小于基准的
    $right_array = array();  //大于基准的
    for($i=1; $i&lt;$length; $i++) {
        if($base_num &gt; $arr[$i]) {
            //放入左边数组
            $left_array[] = $arr[$i];
        } else {
            //放入右边
            $right_array[] = $arr[$i];
        }
    }
    //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数
    $left_array = quickSort($left_array);
    $right_array = quickSort($right_array);
    //合并
    return array_merge($left_array, array($base_num), $right_array);
}
print_r(quickSort([3,5,8,6,1,2,7,4,10,9]));
echo &quot;&lt;hr&gt;&quot;;

echo '6、二分查找算法（折半查找算法）&lt;br&gt;';
function binsearch($x,$a){
    $c=count($a);
    $lower=0;
    $high=$c-1;
    while($lower&lt;=$high){
        $middle=intval(($lower+$high)/2);
        if($a[$middle]&gt;$x){
            $high=$middle-1;
        } elseif($a[$middle]&lt;$x){
            $lower=$middle+1;
        } else{
            return $middle;
        }
    }
    return false;
}
echo binsearch(1,[3,5,8,6,1,2,7,4,10,9]);
echo &quot;&lt;hr&gt;&quot;;

echo &quot;7、PHP奇异算法&lt;br&gt;&quot;;
function bizarrerie(){
	$a=1;
	$b=&amp;$a;
	echo (++$a)+(++$a);
}
bizarrerie();
echo &quot;&lt;hr&gt;&quot;;

echo &quot;8、字符集合：输入一个字符串，求出该字符串包含的字符集合，并按顺序排序（英文）&lt;br&gt;&quot;;
function set($str){
    //转化为数组
    $arr = str_split($str);
    //去除重复
    $arr = array_flip(array_flip($arr));
    //排序
    sort($arr);
    //返回字符串
    return implode('', $arr);
}
set('asdf');
echo &quot;&lt;hr&gt;&quot;;

echo &quot;9、遍历一个文件下的所有文件和子文件夹下的文件&quot;;
function AllFile($dir){
    if($dh = opendir($dir)){
        while (($file = readdir($dh)) !== false){
            if($file !='..' &amp;&amp; $file !='.'){
                if(is_dir($dir.'/'.$file)){
                    AllFile($dir.'/'.$file);    //如果判断还是文件，则递归
                }else{  
                    echo $file.'&lt;br&gt;';         //输出文件名
                }
            }
        } 
    }
}
AllFile('/');
echo &quot;&lt;hr&gt;&quot;;

echo &quot;10、从一个标准的Url提取出文件的扩展名&quot;;
function getExt($url) {
    $arr = parse_url($url);
    $file = basename($arr['path']);// basename函数返回路径中的文件名部分
    $ext = explode('.', $file);
    return $ext[count($ext)-1];
}
echo getExt('http://www.baidu.com/a.html');
echo &quot;&lt;hr&gt;&quot;;

echo &quot;11、有个人想上一个n级的台阶，每次只能迈1级或者迈2级台阶，问：这个人有多少种方法可以把台阶走完？例如：总共3级台阶，可以先迈1级再迈2级，或者先迈2级再迈1级，或者迈3次1级总共3中方式&quot;;
function jieti($num){   //实际上是斐波那契数列
    return $num&lt;2?1:jieti($num-1)+jieti($num-2);
}
jieti(5);
echo &quot;&lt;hr&gt;&quot;;

echo &quot;12、请写一段PHP代码，确保多个进程同时写入同一个文件成功&quot;;
function fp(){
	$fp = fopen(&quot;lock.txt&quot;,&quot;w+&quot;);
    if (flock($fp,LOCK_EX)) {
        //获得写锁，写数据
        fwrite($fp, &quot;write something&quot;);
        // 解除锁定
        flock($fp, LOCK_UN);
    } else {
        echo &quot;file is locking...&quot;;
    }
    fclose($fp);
}
echo fp();
echo &quot;&lt;hr&gt;&quot;;

echo &quot;13、无限级分类&quot;;
function tree($arr,$pid=0,$level=0){
    static $list = array();
    foreach ($arr as $v) {
        //如果是顶级分类，则将其存到$list中，并以此节点为根节点，遍历其子节点
        if ($v['pid'] == $pid) {
            $v['level'] = $level;
            $list[] = $v;
            tree($arr,$v['id'],$level+1);
        }
    }
    return $list;
}
$arr = [
	['id'=&gt;1,'pid'=&gt;0],
	['id'=&gt;2,'pid'=&gt;0],
	['id'=&gt;3,'pid'=&gt;1],
	['id'=&gt;4,'pid'=&gt;1],
	['id'=&gt;5,'pid'=&gt;2],
	['id'=&gt;6,'pid'=&gt;2],
];
print_r(tree($arr));
echo &quot;&lt;hr&gt;&quot;;

echo &quot;14、获取上个月第一天 和 最后一天&lt;br&gt;&quot;;
//获取上个月第一天
echo date('Y-m-01',strtotime('-1 month')).'&lt;br&gt;';
//获取上个月最后一天
echo date('Y-m-t',strtotime('-1 month')).'&lt;br&gt;';
echo &quot;&lt;hr&gt;&quot;;

echo &quot;15、随机输入一个数字能查询到对应的数据区间&lt;br&gt;&quot;;
//把区间换成数组写法，用二分法查找区间
function binsearchs($x,$a){  
    $c=count($a);  
    $lower=0;  
    $high=$c-1;  
    while($lower&lt;=$high){  
        $middle=intval(($lower+$high)/2);  
        if($a[$middle]&gt;=$x){  
            $high=$middle-1;
        }elseif($a[$middle]&lt;=$x ){  
            $lower=$middle+1;
        }   
    }
    return '在区间'.$a[$high].'到'.$a[$lower];
}
$array  = ['1','50','100','150','200','250','300'];
$a = '120';
echo binsearchs($a,$array);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义手机端中间弹出框]]></title>
        <id>https://oackrevv.github.io/post/ohjTOU7kG/</id>
        <link href="https://oackrevv.github.io/post/ohjTOU7kG/">
        </link>
        <updated>2022-10-28T03:03:26.000Z</updated>
        <content type="html"><![CDATA[<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;&gt;
	&lt;title&gt;手机端中间弹出&lt;/title&gt;
	&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
	&lt;style lang=&quot;scss&quot;&gt;
	.cu-mask{
		position: fixed;
		z-index: 999;
		top: 0;
		right: 0;
		left: 0;
		bottom: 0;
		background: rgba(0,0,0,.6);
	}
	.cu-modal{
		position: fixed;
		z-index: 999;
		width: 90%;
		max-width: 300px;
		top: 50%;
		left: 50%;
		transform: translate(-50%,-50%);
		background-color: #fff;
		border-radius: 3px;
		overflow: hidden;
	}
	.cu-modal__hd{
		padding:15px 30px;
		text-align: center;
	}
	.cu-modal__title{
		font-weight: 400;
		font-size: 18px;
		overflow: hidden;
		text-overflow: ellipsis;
	}
	.cu-modal__bd{
		padding: 20px;
		min-height: 40px;
		font-size: 15px;
		line-height: 1.4;
		color: #999;
		max-height: 400px;
		overflow-y: auto;
	}
	.cu-modal__ft{
		position: relative;
		line-height: 48px;
		font-size: 18px;
		display: flex;
		text-align: center;
	}
	.cu-modal__btn{
		display: block;
		flex: 1;
		color: #3cc51f;
		text-decoration: none;
		position: relative;
	}
	.cu-modal__btn:nth-child(1){
		color: #353535;
	}
	.cu-modal__btn:after{
		content: &quot;&quot;;
		position: absolute;
		left: 0;
		top: 0;
		width: 1px;
		bottom: 0;
		border-left: 1px solid #d5d5d6;
		color: #d5d5d6;
		transform-origin: 0 0;
		transform: scaleX(.5);
	}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div class=&quot;cu-mask&quot;&gt;&lt;/div&gt;
		&lt;div class=&quot;cu-modal&quot;&gt;
		&lt;div class=&quot;cu-modal__hd&quot;&gt;
			&lt;text class=&quot;cu-modal__title&quot;&gt;发布协议&lt;/text&gt;
		&lt;/div&gt;
		&lt;div class=&quot;cu-modal__bd&quot;&gt;
			&lt;p&gt;　　甲方：&lt;br /&gt;
			　　乙方：&lt;br /&gt;
			　　甲乙双方经过友好协商，就乙方向甲方提供互联网信息发布服务，达成如下协议。&lt;br /&gt;
			　　一、协议内容&lt;br /&gt;
			　　&amp;nbsp;1 、甲、乙双方商定，甲方在乙方所属网站（ xxxx ）上发布 xx 展会信息展示，甲方提供相关图文的双语资料，放置位置为网站英文版 other news ＆ eventsl 栏目和网站中网版的企业频道。&lt;br /&gt;
			　　&amp;nbsp;2 、甲方在乙方所发布全部信息内容需符合国家有关互联网法规规定；&lt;br /&gt;
			　　&amp;nbsp;3 、经双方商定，甲方在乙方网站的发布信息时间为 ______ 年 ______ 月 ______ 日起至 ______ 年 ______ 月 ______ 日止，乙方收费标准为一次性收费人民币 XX 元整。费用在本协议签订后 3 日内甲方以汇款方式向乙方交付，乙方出具正规发票；&lt;br /&gt;
			　　&amp;nbsp;4 、汇入行相关资料：&lt;br /&gt;
			　　二、其他内容&lt;br /&gt;
			　　协议期间乙方如因上级政策、国家法规等因素影响，对甲方发布信息位置改动，需与甲方协商方可进行；&lt;br /&gt;
			　　三、协议有效期限&lt;br /&gt;
			　　本协议自甲、乙两方签字盖章之日起生效，有效期至 &amp;nbsp; 年 &amp;nbsp; 月 &amp;nbsp; 日 &amp;nbsp; 。&lt;/p&gt;
		&lt;/div&gt;
		&lt;div class=&quot;cu-modal__ft&quot;&gt;
			&lt;div class=&quot;cu-modal__btn cu-modal__btn_default&quot;&gt;取消&lt;/div&gt;
			&lt;div class=&quot;cu-modal__btn cu-modal__btn_default&quot;&gt;确定&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190809180426792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDM3ODM4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>